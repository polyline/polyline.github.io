<!-- OK -->

<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Chen Tse-Pei's Blog</title>

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">

<!-- jQuery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

<!-- Latest compiled JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

<!-- Font Awesome -->
<script defer src="/res/js/fontawesome-all.js"></script>

<!-- My CSS -->
<link href="/res/css/common.css" rel="stylesheet">


	</head>
	<body>		
		<header>
			<!-- OK -->

<nav class="navbar navbar-default nav-color">
<div class="container">
      <!-- the header of nav-bar, including the name and the stacking setting -->
      <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>                        
          </button>
          <a class="navbar-brand" href="/index.html">Tsu-Pei Blog</a>
      </div>
      <!--Menu-->
      <div class="collapse navbar-collapse" id="myNavbar">
      <ul class="nav navbar-nav navbar-right">
        <li class="nav-item">
            <a class="nav-link active" href="/index.html">About Me</a>
        </li>
        <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Articles</a>
            <div class="dropdown-menu dropdown-color" aria-labelledby="navbarDropdown">
              <a class="dropdown-item" href="/posts">All</a>
              <a class="dropdown-item" href="/posts/categories/cs">cs</a>
              <a class="dropdown-item" href="/posts/categories/life">life</a>
              <a class="dropdown-item" href="/posts/categories/jp">jp</a>
            </div>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="/works">Works</a>
        </li>
      </ul>
      </div>
</div>
</nav>

		</header>
		<main>
			<!-- OK -->

<div class="container-fluid text-center">
	<div class="row bg-color">
		<div class="col-md-2 col-sm-0">

		</div>
		<div class="view-home col-md-8 col-sm-12 home-color">
			
	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>Naive Bayes Classifier</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="介紹">介紹</h2>
<hr />

<p>這邊是第二次看到Naive Bayes Classifier</p>

<p>第一次是在學Machine Learning的時候，給定已知的數據來預估未知的數據</p>

<p>使用Naive Bayes Classifier有幾個優點，在我們缺少某個資料(missing values)時還是能夠計算出相對應的機率</p>

<p>它有一個假設是，各個feature之間是獨立(independent)，稱為Naive Bayes Assumption</p>

<p>用在確定獨立的feature當然是沒問題，但實驗證明用在可能依賴的features也有不錯的表現</p>

<p>另外，在NLP這邊，我們想把Naive Bayes Classifier運用在Text categorization task of sentiment analysis上</p>

<p>如果給定一個文件，我們能否判斷出它屬於哪個類別</p>

<p>最常見是，判斷一個文件是positive還是negative</p>

<hr />
<h2 id="推導">推導</h2>
<hr />

<p>先稍微整理一下整個推導的過程：</p>

<ol>
  <li>
    <p>我們的目的，給定一個文件d，要求出最有可能的類別c</p>

    <p><img src="https://i.imgur.com/fChgb0a.png" alt="my equation" /></p>
  </li>
  <li>將Bayes Theorem套用在這裡</li>
  <li>
    <p>由於文件的機率P(d)對於不同的類別來說一樣，我們可以視為常數省略</p>

    <p>如此一來，我們可以得出以下式子</p>

    <p><img src="https://i.imgur.com/K2IKmg0.png" alt="my equation" /></p>

    <p>the highest product of Likelihood and Prior is our answer</p>

    <p>但是，對於計算這樣的Likelihood還是有點困難</p>
  </li>
  <li>不失一般性的情況，我們能用a set of festures來表示一個文件d</li>
  <li>在這裡再帶入兩個假設：Bag of words和Naive Bayes Assumption</li>
  <li>最後，避免overflow的情況，我們用log space來表示，這樣就得到最後的式子了</li>
</ol>

<p><img src="https://i.imgur.com/LbTk6XH.png" alt="my equation" /></p>

<hr />
<h2 id="optimizing-for-sentiment-analysis">Optimizing for Sentiment Analysis</h2>
<hr />

<p>有幾件常被加在NB Text Classification的方法</p>

<ol>
  <li>
    <p>Binary NB</p>

    <p>通常，一個字有沒有出現，會比字出現的次數來得重要，所以我們可以只看字有無出現，也就是0或1</p>
  </li>
  <li>
    <p>Deal with Negation</p>

    <p>在英文中，有時候在否定的狀況，字會是完全相反的意思</p>

    <p>我們看下面這個例子</p>

    <p>didn’t like this movie, but I</p>

    <p>如果把字拆開，我們看like會好像是正面的意思，但其實這是否定的句子，所以反而要是負面的意思才對</p>

    <p>這邊我們可以做個處理，將句子改寫成這樣</p>

    <p>didn’t NOT_like NOT_this NOT_movie, but I</p>
  </li>
  <li>
    <p>using Sentiment Lexicons</p>

    <p>有時候，我們並沒辦法在每個字都labeled上class，這時可以利用一些sentiment lexicon來補</p>
  </li>
</ol>


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/24/Naive-Bayes-Classifier.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>[讀]Probability Distribution</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="前言">前言</h2>
<hr />

<p>接續著我們前一篇求Maximum Likelihood的文章繼續，接下來我們要來看幾個常見的Distribution</p>

<p>為了好好學習好，讓我們回到大二的機率課本：<em>FUNDAMENTALS OF PROBABILITY WITH STOCHASTIC PROCESSES</em></p>

<p>裡面的第四章節到第九章節，從Random Variable開始講解，然後從Discrete Distribution到Continuous Distribution</p>

<p>同時也提到一些常用的Distribution，像是Possion Distribution等等</p>

<p>我們預計花一個禮拜的時間好好複習一下這邊</p>

<hr />
<h2 id="going-to-read">Going to Read</h2>
<hr />

<h4 id="chapter-4">Chapter 4</h4>
<ul>
  <li>4.1 Random Variables</li>
  <li>4.2 Distribution Functions</li>
  <li>4.3 Discrete Random Variables</li>
  <li>4.4 Expectation of Discrete Random Variables</li>
</ul>

<p><em>Finished</em></p>

<h4 id="chapter-5">Chapter 5</h4>
<ul>
  <li>5.1 Bernoulli and Binomial Random Variables</li>
  <li>5.2 Possion Random Variables</li>
</ul>

<hr />
<h2 id="random-variables">Random Variables</h2>
<hr />

<p><em>First Day</em></p>

<p>我們首先來理解一下Random Variable的定義：</p>

<blockquote>
  <p>The values of such quantities depend on random actions, and they usually change from one experiment to another</p>
</blockquote>

<p>也就是在每一次的實驗中，得到的結果都會不同時，我們稱它為Random Variable</p>

<p>在完整的數學定義中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Let S be the sample space of an experiment. A real-valued function X : S → R is called a random variable of the experiment if, for each interval I ⊆ R , {s: X(s) ∈ I} is an event.
</code></pre>
</div>

<p>讓我們來看一個例子，假設我們今天骰三次骰子，求骰到人頭面的次數有多少</p>

<p>骰子的各種結果組合就是我們的S，而人頭面的次數就是我們的R</p>

<p>我們可以說，S是包含Random Variable所有可能的集合，而X是一個S → R的Function，將S用一個實數來表示</p>

<hr />

<p>從原本的Random Variable中，也能產生新的Random Variable，在以下的條件下</p>

<ol>
  <li>假設有兩個Random Variable, X和Y，在同個定義域S，並且對應到值域R，那麼<code class="highlighter-rouge">X+Y</code>, <code class="highlighter-rouge">X-Y</code>, <code class="highlighter-rouge">aX+bY</code>, <code class="highlighter-rouge">XY</code>, <code class="highlighter-rouge">X/Y, Y!=0</code>也都是Random Variables</li>
  <li>對於實數對應到實數的function來說，與Random Variable X的composition也還是S → R，所以還是Random Variable，例如<code class="highlighter-rouge">sin X</code>, <code class="highlighter-rouge">cos X2</code>, <code class="highlighter-rouge">eX</code>, <code class="highlighter-rouge">X3 − 2X</code></li>
</ol>

<p>所以我們看<strong>Example4.5 Disk的範例</strong>就可以很清楚，一開始Random Variable是直徑D，改成求面積也還是一樣符合Random Variable的定義</p>

<hr />
<h2 id="distribution-functions">Distribution Functions</h2>
<hr />

<blockquote>
  <p>Definition: If X is a random variable, then the function F defined on (−∞, +∞) by F(t) = P(X ≤ t) is called the distribution function of X</p>
</blockquote>

<p>我們只需要求出<code class="highlighter-rouge">P(X ≤ t)</code>，就可以求出其他所有的機率：P(X = a), P(X &lt; a), P(X ≤ a), P(X &gt; b), P(X ≥ b), P(b ≤ X ≤ a), P(b &lt; X ≤ a), P(b ≤ X &lt; a), and P(b &lt; X &lt; a)</p>

<p>以下是一些關於<code class="highlighter-rouge">F</code>的性質</p>

<ol>
  <li>F is nondecreasing</li>
  <li>lim(t →∞) F(t) = 1</li>
  <li>lim(t→−∞) F(t) = 0</li>
  <li>F is right continuous</li>
</ol>

<p>利用這些性質，我們就可以求出上面那些其他區間的機率</p>

<hr />

<p>根據<code class="highlighter-rouge">Remark 4.1</code>，我們也可以反推回來，如果一個function F，滿足以上四個條件，那麼一定存在一個Random Variable X over S，使得X的Distribution Function是F</p>

<hr />
<h2 id="discrete-random-variables">Discrete Random Variables</h2>
<hr />

<p>Random Variable的集合，可以是Countable, finitely countable, uncountable. 如果是countable或者finitely countable的話，我們稱之為<code class="highlighter-rouge">Discrete Random Variables</code></p>

<blockquote>
  <p>Definition: The probability mass function p of a random variable X whose set of possible values is {x1 , x2 , x3 , . . . } is a function from R to R that satisfies the following properties</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>a. p(x) = 0 if x !∈ {x1,x2,x3,...}.
b. p(xi) = P(X = xi) and hence p(xi) ≥ 0 (i = 1,2,3,...).
c. ∑p(xi) = 1
</code></pre>
</div>

<p>所以，如果存在一個countable的set{x1, x2, x3, …}，並且滿足p: R→R，使得p(xi) &gt;= 0(i=1,2,3,…)，並且P(xi) = 0，如果xi !∈{x1,x2,x3, …}，且∑p(xi)= 1，則我們可以稱p是<code class="highlighter-rouge">probability mass function</code>。</p>

<p><code class="highlighter-rouge">probability mass function</code>的<code class="highlighter-rouge">distribution function</code>很簡單，只是將離散的pmf機率相加即可得到</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x1 &lt;= t &lt; x2
F(t) = p(X &lt;= t) = p(x1)
以此能夠類推到
xn-1 &lt;= t &lt; xn
F(t) = p(X &lt;= t) = p(x1) + p(x2) + ... + p(xn-1)
</code></pre>
</div>

<hr />
<h2 id="expectation-of-discrete-random-variables">Expectation of Discrete Random Variables</h2>
<hr />

<p>這個章節算是複習，再加上一些補充的知識</p>

<p><code class="highlighter-rouge">Expectation</code>(期望值)，在<code class="highlighter-rouge">pmf</code>中，只要將每個機率與對應到的x相乘就是答案</p>

<div class="highlighter-rouge"><pre class="highlight"><code>E(X) =   ∑xp(x)
We say E(x) exists only if this sum converge absolutely
</code></pre>
</div>

<p>期望值要收斂才會存在</p>

<hr />

<p><code class="highlighter-rouge">St. Petersburg Paradox</code>，如果我們說，丟一個硬幣，直到丟到第一次出現正面(head)時，是第k次，那麼可以獲得<code class="highlighter-rouge">2^k</code>的錢</p>

<p>根據這個敘述得到的期望值會是</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1+1+1+1+... = ∞
</code></pre>
</div>

<p>課本中提了幾個<code class="highlighter-rouge">期望值發散</code>的範例，有時間可以回來再看:example 4.19~4.22</p>

<hr />

<blockquote>
  <p>Theorem 4.2: Let X be a discrete random variable with set of possible values A and probability mass function p(x), and let g be a real-valued function. Then g(X) is a random variable with</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>E[g(X)]  =   ∑ g(x)p(x).
</code></pre>
</div>

<p>也就是當我們將原本的Random Variable X套進一個<code class="highlighter-rouge">real-valued function</code> g(x)中，g(X)也還是Random Variable(根據前面的說明)，期望值就可以根據上述的式子得出，詳細的證明可以參考課本。</p>

<hr />

<p>Collary: E(X)是線性的，也就是</p>

<div class="highlighter-rouge"><pre class="highlight"><code>E(∂X+ß) = ∂E(X)+ß
</code></pre>
</div>

<hr />
<h2 id="bernoulli-random-variable-and-binomial-random-variables">Bernoulli Random Variable And Binomial Random Variables</h2>
<hr />
<p><em>Second Day</em></p>

<p>關於<code class="highlighter-rouge">Bernoulli</code>，大家應該都相當了解，也就是只有兩種結果的事件，像是擲硬幣只會也正面或反面兩種情況</p>

<blockquote>
  <p>They have only two possible outcomes. One outcome is usually called a success, denoted by s. The other outcome is called a failure, denoted by f</p>
</blockquote>

<blockquote>
  <p>The sample space of a Bernoulli trial contains two points, s and f . The random variable defined by X(s) = 1 and X(f ) = 0 is called a Bernoulli random variable</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>For a Bernoulli random variable X with parameter p, 0 &lt; p &lt; 1, E(X)=p, Var(X)=p(1−p), σX = √p(1−p).
</code></pre>
</div>

<p>而我們如果重複<code class="highlighter-rouge">Bernoulli Experiment</code> n次的話，我們就會得到<code class="highlighter-rouge">Binomial Probability Mass Function</code></p>

<blockquote>
  <p>Definition: The function p(x) given by equation (5.2) is called the binomial probability mass function with parameters (n, p)</p>
</blockquote>

<p>這邊的<strong>Example 5.6</strong>還蠻有趣的，如果陪審團中，一個人做對決定的機率是p，那麼三人的陪審團跟一人的陪審員，誰做對決定的機率比較高？</p>

<p>我們可以先看三人陪審團，最後決定的方式是簡單多數決，所以就是至少兩個人做對決定時，我們記做<code class="highlighter-rouge">P(X &gt;= 2)</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>P(X &gt;= 2) = P(X = 2) + P(X = 3) = 3p^2 * (1-p) + p^3 = -2p^3 + 3p^2
</code></pre>
</div>

<p>假設三人陪審團做對決定的機率較高</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-2p^3 + 3p^2 &gt; p
=&gt; -2p^2 + 3p &gt; 1
=&gt; 2(1-p)(p-1/2) &gt; 0
</code></pre>
</div>

<p>所以，當<code class="highlighter-rouge">p&gt;1/2</code>時，三人陪審團做對決定機率較大，反之，單人陪審員做對決定機率較大</p>

<div class="highlighter-rouge"><pre class="highlight"><code>If X is a binomial random variable with parameters n and p, then E(X)=np, Var(X)=np(1−p), σX = √np(1−p).
</code></pre>
</div>

<hr />
<h2 id="poisson-random-variables">Poisson Random Variables</h2>
<hr />

<p>Poisson Random Variable是將Binominal Random Variable展開後，如果<code class="highlighter-rouge">n趨近於無限大</code>，所推論出來的式子</p>

<p>所有可能的P(X = xi)相加(i=0,1,2,…,n)也會等於，證明<code class="highlighter-rouge">Probability of Poisson Random Variable</code>是<code class="highlighter-rouge">pmf</code></p>

<blockquote>
  <p>Definition A discrete random variable X with possible values 0, 1, 2, 3, . . . is called Poisson with parameter λ, λ &gt; 0, if</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>P(X=i)= (e^-λ * λ^i) / i! , i=0,1,2,3,....
</code></pre>
</div>

<p>而Poisson也能當作Binomial一種approximation，在<code class="highlighter-rouge">p&lt;0.1</code>, <code class="highlighter-rouge">np&lt;=10</code>的情況下可以有很好的表現</p>

<p>Poisson的Expectation跟Variance都是λ，推論請參考課本</p>

<div class="highlighter-rouge"><pre class="highlight"><code>If X is a Poisson random variable with parameter λ, then E(X) = Var(X) = λ, σX = √λ.
</code></pre>
</div>


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/23/s_distribution.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>webpack筆記</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="什麼是webpack為什麼需要學">什麼是webpack，為什麼需要學？</h2>
<hr />

<p>一樣的，我們先從維基百科的定義來看</p>

<blockquote>
  <blockquote>
    <p>Webpack 是一個開源的前端打包工具。Webpack 提供了前端開發缺乏的模組化開發方式，將各種靜態資源視為模組，並從它生成優化過的程式碼</p>
  </blockquote>
</blockquote>

<p>其實維基百科已經用簡短的一句話說明了webpack最重要的兩個功能</p>

<ol>
  <li>改善模組化產生的效能跟管理問題</li>
  <li>優化後生成bundle.js</li>
</ol>

<p>因為現在有太多用javaScript所撰寫的套件</p>

<p>而webpack是一個能統一管理這些套件，並替我們處理掉考慮這些js檔案相依的問題</p>

<p>例如該先import哪個檔案等等</p>

<p>最後直接輸出一個Bundle.js讓我們能夠直接import這個檔案</p>

<p>這是官網提供的webpack流程圖</p>

<p><a href="\res\photo\webpack.jpg">!webpack</a></p>

<p>以下的筆記主要是參考這個<a href="https://www.jianshu.com/p/42e11515c10f">部落格</a>和<a href="https://webpack.js.org/guides/getting-started/">官方文件</a>來透過實作練習<code class="highlighter-rouge">webpack</code>的功能</p>

<p>練習的檔案上傳在我的<a href="">github</a></p>

<hr />
<h2 id="安裝install">安裝(install)</h2>
<hr />

<div class="highlighter-rouge"><pre class="highlight"><code>npm install --save-dev webpack
</code></pre>
</div>

<p>我們可以很簡單的透過<code class="highlighter-rouge">npm</code>來安裝<code class="highlighter-rouge">webpack</code></p>

<p>當然，也可以選擇全局安裝</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install -g webpack
</code></pre>
</div>

<hr />
<h2 id="配置文件configuration">配置文件(Configuration)</h2>
<hr />

<p>在這之前，可以先參考<a href="https://www.jianshu.com/p/42e11515c10f">入门Webpack，看这篇就够了</a>或者<a href="https://webpack.js.org/guides/getting-started/">webpack-官方文件</a>最一開始的部分</p>

<p>我們可以在<code class="highlighter-rouge">terminal</code>上直接執行<code class="highlighter-rouge">webpack</code></p>

<p>例如在官方文檔中的</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npx webpack src/index.js --output dist/bundle.js
</code></pre>
</div>

<p><code class="highlighter-rouge">src/index.js</code>是原始文件，而<code class="highlighter-rouge">dist/bundle.js</code>是輸出文件的位置</p>

<p>但是這樣在terminal上執行太過麻煩，所以我們可以透過新增一個配置文件<code class="highlighter-rouge">webpack.config.js</code>來替代</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const path = require('path');
module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist')
  }
};
</code></pre>
</div>

<p><code class="highlighter-rouge">entry</code>表示<code class="highlighter-rouge">入口文件</code>的位置</p>

<p><code class="highlighter-rouge">output</code>表示<code class="highlighter-rouge">輸出文件</code>的的<code class="highlighter-rouge">名稱</code>跟<code class="highlighter-rouge">路徑</code></p>

<p>之後，我們可以把執行<code class="highlighter-rouge">webpack</code>這件事情加到<code class="highlighter-rouge">package.json</code>的腳本中</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
	  </span><span class="nt">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
	    </span><span class="nt">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="p">,</span><span class="w">
	    </span><span class="nt">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"webpack"</span><span class="w">
	  </span><span class="p">},</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<p>所以當我們執行</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm run start
</code></pre>
</div>

<p>就能夠看到執行完<code class="highlighter-rouge">webpack</code>的結果了</p>

<hr />
<h2 id="使用webpack-dev-server本地端伺服器">使用webpack-dev-server（本地端伺服器）</h2>
<hr />

<p><code class="highlighter-rouge">webpack</code>提供我們一個伺服器，讓我們可以用於開發測試</p>

<p>提供了一些功能，像是當程式碼有變化時，自動刷新等</p>

<p>首先我們必須安裝這個套件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install --save-dev webpack-dev-server
</code></pre>
</div>

<p>之後在<code class="highlighter-rouge">webpack.config.js</code>中加入<code class="highlighter-rouge">webpack-dev-server</code>的一些選項</p>

<div class="highlighter-rouge"><pre class="highlight"><code>devServer: {
	contentBase: "./public",
	historyApiFallback: true,
	inline: true
} 
</code></pre>
</div>

<p><code class="highlighter-rouge">contentBase</code>就是我們主頁面的位置</p>

<p><code class="highlighter-rouge">inline</code>是文件改變時，會不會自動刷新頁面</p>

<p><code class="highlighter-rouge">historyApiFallback</code>是讓所有跳轉指向<code class="highlighter-rouge">index.html</code></p>

<p>再來，還要在<code class="highlighter-rouge">package.json</code>中加上<code class="highlighter-rouge">script</code>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
	  </span><span class="nt">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
	    </span><span class="nt">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="p">,</span><span class="w">
	    </span><span class="nt">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"webpack"</span><span class="p">,</span><span class="w">
	    </span><span class="nt">"server"</span><span class="w"> </span><span class="nt">"webpack-dev-server --open"</span><span class="w">
	  </span><span class="err">}</span><span class="p">,</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
</div>

<hr />
<h2 id="source-maps">Source maps</h2>
<hr />

<p>但是<code class="highlighter-rouge">webpack</code>這樣的運作方式可能會有一個問題</p>

<p>開發後，當我們測試中發生錯誤時</p>

<p>因為所有檔案已被<code class="highlighter-rouge">webpack</code>打包成了<code class="highlighter-rouge">bundle.js</code></p>

<p>所以很難找到錯誤點，可讀性不高</p>

<p>這個時候可以透過<code class="highlighter-rouge">Source maps</code>來解決這個問題</p>

<p>我們要在<code class="highlighter-rouge">配置文件</code>中新增<code class="highlighter-rouge">devtool</code>這個屬性</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module.exports = {
	devtool: 'eval-source-map'
	...
}
</code></pre>
</div>

<p>我們能夠選擇的<code class="highlighter-rouge">source map</code>一般來說有四種</p>

<ol>
  <li>source-map</li>
  <li>cheap-module-source-map</li>
  <li>eval-source-map</li>
  <li>cheap-module-eval-source-map</li>
</ol>

<p>其中的差異在這邊不多說，但是由上至下打包速度越快，可讀性越低</p>

<hr />
<h2 id="模塊加載器loader">模塊加載器(Loader)</h2>
<hr />

<p><code class="highlighter-rouge">webpack</code>能透過<code class="highlighter-rouge">loader</code>來對不同格式的文件做處理</p>

<p>例如將<code class="highlighter-rouge">sass</code>轉成<code class="highlighter-rouge">css</code>、<code class="highlighter-rouge">JSX文件</code>轉成<code class="highlighter-rouge">JS文件</code>等等</p>

<p>要使用<code class="highlighter-rouge">Loader</code>，必須在<code class="highlighter-rouge">webpack.config.js</code>中作配置</p>

<p>我們將會使用<code class="highlighter-rouge">Babel</code>，所以在<code class="highlighter-rouge">webpack.config.js</code>中加入：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module.exports = {
	...,
	module:{
		rules: [
			{
				test:/(\.jsx|\.js)$/,
				use:{
					loader: "bable-loader",
					options: {
						presets:[
							"env", "react"
						]
					}
				},
				exclude: /node_modules/
			}
		]
	}
}
</code></pre>
</div>

<p>安裝<code class="highlighter-rouge">Babel</code>相關的依類包</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react
</code></pre>
</div>

<p>完成到這裡，代表<code class="highlighter-rouge">webpack</code>允許我們使用<code class="highlighter-rouge">ES6</code>以及<code class="highlighter-rouge">JSX</code>的語法了</p>

<p><code class="highlighter-rouge">loader</code>會去尋找在我們指定的目錄下的<code class="highlighter-rouge">jsx</code>跟<code class="highlighter-rouge">js</code>檔</p>

<p>並且將他們轉換成瀏覽器所接受的語言</p>

<p>於是，我們可以引進<code class="highlighter-rouge">React.js</code>的語法了</p>

<p>在這裡，我們是把Babel的配置直接寫在<code class="highlighter-rouge">webpack.config.js</code>中</p>

<p>但是我們也能加它分離到另一個檔案<code class="highlighter-rouge">.babelrc</code></p>

<p>編譯時就會自動讀取了<code class="highlighter-rouge">.babelrc</code>文件</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//.babelrc
{
	presets:[
		"env", "react"
	]
}
</code></pre>
</div>

<hr />
<h2 id="css相關loader">CSS相關loader</h2>
<hr />

<p>除了轉化JSX語法，我們也能使用loader來達到CSS模塊化的功能</p>

<p>這邊我們使用<code class="highlighter-rouge">css-loader</code>和<code class="highlighter-rouge">style-loader</code></p>

<p>而為了讓<code class="highlighter-rouge">webpack</code>能找到<code class="highlighter-rouge">css</code>，所以我們必須在我們的</p>

<p>入口檔案<code class="highlighter-rouge">main.js</code>裡面引進<code class="highlighter-rouge">css</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>module:{
	rules: [
		{...},
		{
			test: /\.css$/,
			use:[
				{
					loader: "style-loader"
					},
				{
					loader: "css-loader",
					options: {
						modules: true,
						localIdentName: '[name]__[local]--[hash:base64:5]'
					}
				}
			]
		}
	]
}
</code></pre>
</div>

<p>之後，我們便可以在js檔案中引進<code class="highlighter-rouge">css模塊</code>來使用</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//./main.css
.root {
	...
}

//./main.js
...
import main-css from './main.css';
...
	render(){
		return(
			&lt;div className={main-css.root}&gt;
					Hello!
			&lt;/div&gt;
			);
	}
...
</code></pre>
</div>

<hr />
<h2 id="postcss-webpack-plugins">postcss webpack-plugins</h2>
<hr />

<p>套件是對整個<code class="highlighter-rouge">webpack</code>建構過程作用</p>

<p>而<code class="highlighter-rouge">loader</code>則是處理源文件</p>

<p>常常使用的套件有這些：</p>

<ol>
  <li>html-webpack-plugin</li>
  <li>Hot Module Replacement(HMR)</li>
</ol>

<p><code class="highlighter-rouge">html-webpack-plugin</code>能根據一個html模板來產生對應的<code class="highlighter-rouge">index.html</code>文件</p>

<p>例如，我們創建一個模板文件在<code class="highlighter-rouge">./app/index.templ.html</code></p>

<p>然後必須在<code class="highlighter-rouge">webpack.config.json</code>中添加相關訊息</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module.export = {
	...,
	output: {
		path: __dirname + "/build", //將webpack編譯後的文件存放在build資料夾中
		filename: "build.js"
	},
	...,
	plugins: [
		new webpack.BannerPlugin('Made by Chen, Tsu Pei'), // BannerPlugin 能在產生的代碼中加上版權宣告文字
		new HtmlWebpackPlugin({
				template: __dirname + "./app/index.templ.html" // 參考用的源html代碼文件
			})
	]
}
</code></pre>
</div>

<p><code class="highlighter-rouge">HMR</code>則是可以實現<code class="highlighter-rouge">熱加載</code>的功能，也就是當我們開發實作的更改</p>

<p>能即時在網頁上刷新</p>

<p>要使用<code class="highlighter-rouge">HMR</code>的話，我們必須做三件事情</p>

<ol>
  <li>在webpack配置文件夾加上HMR插件</li>
  <li>在webpack dev server加上hot參數</li>
  <li>在JS文件中，調用webpack提供的API</li>
</ol>

<p>讓我們先來完成前兩件事情</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module.export = {
	...,
	devServer: {
		...,
		hot: true
	},
	plugins: [
		new webpack.BannerPlugin('Made by Chen, Tsu Pei'),
		new HtmlWebpackPlugin({
				template: __dirname + "./app/index.templ.html"
			}),
		new webpack.HotModuleReplacementPlugin() //實現熱插件
	]
}
</code></pre>
</div>

<p>關於第三件事情，react模塊可以直接使用Babel更方便的實現熱加載</p>

<p>我們透過一個在<code class="highlighter-rouge">Babel</code>中叫做<code class="highlighter-rouge">react-transform-hrm</code>的套件</p>

<p>就可以不用在<code class="highlighter-rouge">react模塊</code>中載入API而達到熱加載的功能</p>

<p>所以我們要在<code class="highlighter-rouge">.babelrc</code>中做一些配置</p>

<div class="highlighter-rouge"><pre class="highlight"><code>//.babelrc
{
	"presets": ["react", "env"],
	"env": {
		"development": {
			"plugins": [
				[
					"react-transform",
					{
						"transforms":[
							{
								"transform": "react-transform-hmr",
								"imports": ["react"],
								"locals": ["module"]
							}
						]
					}
				]
			]
		}
	}
}
</code></pre>
</div>

<p>當然，這些套件都要事先透過<code class="highlighter-rouge">npm</code>安裝好才能使用</p>

<hr />
<h2 id="來源references">來源(References)</h2>
<hr />

<ol>
  <li><a href="https://www.jianshu.com/p/42e11515c10f">入门Webpack，看这篇就够了</a></li>
  <li><a href="https://zh.wikipedia.org/wiki/Webpack">webpack-wiki</a></li>
  <li><a href="https://webpack.js.org/guides/getting-started/">webpack-官方文件</a></li>
  <li><a href="https://medium.com/@Roy_Huang/新手向-webpack-完全攻略-1-e7981097e6a3">Roy_Huang-新手向-webpack-完全攻略</a></li>
  <li><a href="https://github.com/css-modules/css-modules">css modules</a></li>
</ol>


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/21/webpack%E7%AD%86%E8%A8%98.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>[EN] real-time keyword extraction -incomplete-</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="going-to-do">Going to do!</h2>
<hr />

<ol>
  <li>複習之前那篇論文，然後跟現在讀的這篇結合，看如何應用在live streaming</li>
  <li>現在的state-of-the-art是找出最大的subgraph，並且在其中持續刪除最低分的（the lowerest degree），可能存在改進空間的是，關於sliding window設定的問題，還有文章太短(comment)的問題
    <ol>
      <li>文本太短，使用sliding window很困難</li>
      <li></li>
    </ol>
  </li>
</ol>

<p>Problems of meeting scripts</p>
<ol>
  <li>multi-party</li>
  <li>short</li>
</ol>

<p>Problems of live streaming</p>
<ol>
  <li>need to have enough comments data</li>
  <li>comments could be incomplete</li>
</ol>

<p>把目的再強化一點，這樣可以解決什麼問題</p>

<hr />
<h2 id="preview">Preview</h2>
<hr />

<p>In this work, I would like to collect all related papers of this topic. Try to clarify the most popular methods in this areas. Also, I would also point out some specific features in this work. For examples, multi-party’s utterances would imply diffenct styles.</p>

<p>To briefly introduce my research, I want to analyze comments of a live video, and try to find out some keywords or key concepts in a particular interval. For example, from <em>t=0</em> to <em>t=3</em>, showing a set of keywords, and the next interval <em>t=3</em> to <em>t=6</em>, showing another set of keywords. All of keywords are extracted from comments.</p>

<p>In order to do that, let’s think some related work. First of all, keyword extraction is neccessary, however, most of research of keyword extraction are focus on long and formal articles(ex. news, wiki-document). In this task, we get to focus on <code class="highlighter-rouge">short</code> and <code class="highlighter-rouge">informal</code> documents, but we can still learn some techniques from those, maybe it could be also used in short documents. On the other hand, there are few researches about short and informal documents such as <code class="highlighter-rouge">Tweet</code>, <code class="highlighter-rouge">Meeting Script</code>, <code class="highlighter-rouge">Comments</code> may be helpful.</p>

<p>Besides, real-time is also an important task here. To recap, our input is a sequence of sets of comments in a particular interval. In the live streaming, topics of intervals are suppposed to be <code class="highlighter-rouge">continuously changing</code>, that is, it’s less possible to change topics suddenly between two neighboring intervals. Moreover, information in <code class="highlighter-rouge">previous intervals still could be useful</code> in current interval.</p>

<p>To sum up, we can list:</p>

<ol>
  <li>keyword extraction toward short-documents</li>
  <li>algorithm that can preserve information in past rounds and discard unused information</li>
  <li>process multi-party comments</li>
  <li>unsupervised method(since it’s difficult to get labeled output)</li>
</ol>

<p>And in live streaming, there are some profound features:</p>

<ol>
  <li>comments could be high-repetitive</li>
  <li>information are incompelete<em>*1</em></li>
  <li>order is important, comments are with time-stamp</li>
  <li>compared to keyword extraction from meeting scripts, comments are without imcomplete words, filler words(ex. uh..), interruption.</li>
</ol>

<p><em>*1.</em> Comments in a live streaming could be diaglogue between audience and the host, while we can only analyze comments from audience. That’s also why we only want to extract keywords instead of summary. Our goal is to give a quick knowledge of the topic in the live streaming to new audience.</p>

<hr />
<h2 id="review-keyword-extraction-method">Review Keyword Extraction Method</h2>
<hr />

<ol>
  <li>TF/IDF</li>
  <li>TextRank</li>
  <li>RAKE(Rapid Automatic Keyword Extraction)</li>
  <li></li>
</ol>

<hr />
<h2 id="read-papers">Read Papers</h2>
<hr />

<ol>
  <li>Real-Time Keyword Extraction from Conversations(Polykarpos et al. 2017 EACL)
    <ul>
      <li>k-core decomposition(Batagelj and Zaveršnik 2011)</li>
      <li>centrality + tightly knitted structure(Tixier et al. 2016a)</li>
      <li>CoreRank(CR)</li>
    </ul>
  </li>
  <li>3.
4.</li>
</ol>

<hr />
<h2 id="real-time-keyword-extraction-from-conversationspolykarpos-et-al-2017-eacl">Real-Time Keyword Extraction from Conversations(Polykarpos et al. 2017 EACL)</h2>
<hr />

<ol>
  <li>preprocessing</li>
  <li>each word represented as a vertex</li>
  <li>word co-occurence network, in fixed sliding window size, if two word co-occur, then build a edge between two nodes</li>
  <li>weighted, undirect graph</li>
  <li>k-core decomposition
    <ul>
      <li>counting k-core</li>
      <li>counting CoreRank</li>
      <li>get optimistic subgraph</li>
      <li>counting degree</li>
      <li>delete the vertex of the lowest degree in the subgraph</li>
    </ul>
  </li>
  <li>Keyword Qaulity Function
 Since we  want to extract the best substructure of the graph, we define a quality function as criteria for choosing. We take two factors into accout, CoreRank and how many steps to be a fully connected graph, which imply the graph being highly knitted.</li>
  <li>Time Complexity
    <ul>
      <li>counting k-cores: O(V+Elog(V))</li>
      <li>counting CR: O(V)</li>
    </ul>
  </li>
  <li>Evaluation
 Compare with 5 baseline: random, frequency, RAKE, weighted degree centrality, PageRank.
 In this paper, they used two scenario to evaluate. The first one is the cosine similarity of commulative one-hot word vector between extracted keyword set and the provided extractive summary. The second one is to concatenate all extracted keywords as a summary and use two methods, ROUGE-1, WMD, to compare the similarity with abstractive summary.</li>
  <li>Discussion and related papers
    <ul>
      <li>Lin et al. 2009
        <ul>
          <li>?</li>
        </ul>
      </li>
      <li>Habibi and Popescu-Belis 2003
        <ul>
          <li>LDA and submodularity to select keywords covering as much topics as possible</li>
        </ul>
      </li>
      <li>Meladianos et al. 2015, <em>Degeneracy-Based Real-Time Sub-Event Detection in Twitter Stream</em>
        <ul>
          <li>?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Some Pre-setting or assumption in this paper
    <ul>
      <li>word-embedding - 300-dimensional vectors learned from a 100B-word corpus(Google news)</li>
      <li>assume that at most on topic could be discussed in each interval</li>
    </ul>
  </li>
</ol>

<p><em>PS.</em>
<em>1. We have to calculate time complexity to gaurantee that the performance meets real-time requirement</em>
<em>2. Being with high degree means be more central, and being with high CR means being tightly knitted</em></p>

<hr />
<h2 id="related-work">Related Work</h2>
<hr />


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/16/EN-real-time-keyword-extraction.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>[EN] NLP Review -incomplete-</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="preview">Preview</h2>
<hr />

<blockquote>
  <p>In this articles, I will cover a few good articles that I found on the internet. The goal is to orgnize the resources and notes in the process of learning NLP. The followings are the index of the article.</p>
</blockquote>

<ol>
  <li>Pre-requirments - Suggest what kinds of knowledge are recommanded to gain before starting NLP task</li>
  <li>Resources - The resources that I used to learn NLP</li>
  <li>Read-Papers - I will show a short summary for the papers I read before. Some will have detailed introduction articles</li>
  <li>Concepts - I would like to collect some important concepts related to NLP tasks in this section</li>
  <li>Implementation - In order to make these theories into real work, what kinds of knowledge do we need.</li>
  <li>Experiment Results - In this section, I will show the experiments that I made before.</li>
</ol>

<p>Why I am writting this article in English? It’s because of terminology. I prefer to directly using the original English term to specify the concept or word. Also, Writing in English will be easy to be shared in the world.</p>

<p>Let’s get started!</p>

<hr />
<h2 id="2-resources">[2] Resources</h2>
<hr />

<p>There are two necessary textbooks are really recommended to the beginners in NLP.</p>

<ol>
  <li>PRML</li>
  <li>Speech and Language Processing</li>
</ol>

<p>Also, in NLP, there are also a lot of math, mostly probability. So I will recommand to review this textbook</p>

<ol>
  <li>Saeed-Ghahramani-Fundamentals-of-Probability</li>
</ol>

<p>And here I am listing some famous papers in NLP. The most possibly related region is shown on the subtitle. Also, I tend to collect all related paper(or let’s say variations) together</p>

<p>Let’s take a look:</p>

<ul>
  <li></li>
  <li>[LDA Topic Model, Summarisation]:</li>
  <li>[Word Embedding, Tagging, Labelling]:</li>
  <li>[Recurrent Dropout, Tagging, Labelling]:</li>
  <li>[LexRank, Keyword Extraction]:
    <ul>
      <li>[TextRank]:</li>
    </ul>
  </li>
  <li>[Keyword Extraction]:</li>
  <li>[LSTMs]:</li>
</ul>

<p>Also, I watched a series of courses about ML and DL in coursera.</p>

<ul>
  <li>Machine Learning(by Andrew Ng)</li>
  <li>Deep Learning specialty(by Andrew Ng)</li>
</ul>

<p>Lastly, when I seek information in the internet, I have found many useful articles. For English:</p>

<ul>
  <li></li>
</ul>

<p>and for chinese(both tradional and simplified):</p>

<p>1.</p>

<p>For datasets, since I am doing comments summarisation, There are some available datasets on the internet.</p>

<ul>
  <li>Google’s rebbit data:</li>
</ul>

<hr />
<h2 id="reference">Reference</h2>
<hr />

<ol>
  <li></li>
</ol>

		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/10/EN-NLP-Review.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>[讀]共軛性(conjugacy) -imcomplete- </p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="前言">前言</h2>
<hr />

<p>在繼續研究PRML這本書的Beta Distribution的時候</p>

<p>有個疑問是，為什麼</p>

<p>把Binoninal Distribution當作Likelihood，把Beta Distribution當作Prior</p>

<p>相乘之後就可以得到Posterior Distribution</p>

<p>所以，這篇文章想要再更深入的研究這些問題</p>

<hr />
<h2 id="整理疑惑">整理疑惑</h2>
<hr />

<p>我會在這裡感到疑惑是</p>

<ol>
  <li>不知道為什麼共軛性(conjugacy)的由來</li>
  <li>為什麼Gamma函數可以使Bata分布達到歸一化(sum = 1)的效果</li>
  <li>Beyes’ Theorem以往只知道在機率上的應用，在Distribution上也能直接相乘嗎？</li>
  <li>關於最後面的推導</li>
</ol>

<p><img src="https://i.imgur.com/VbuEkLG.png =x10" alt="my equation" /></p>

<p>conjugate</p>

<p>Beta Distribution - continuous distribution</p>

<p>Gamma Function</p>

<p>Bayes’ Theorem</p>

<p>Prior and Posterior Distribution</p>

<p>Posterior (is proportional to) Likelihood * Prior</p>

		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/02/s_conjugacy.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>[讀]Maximum Likelihood Estimation(MLE)</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="前言">前言</h2>
<hr />

<p>最近在努力複習機率</p>

<p>當初資工大一大二時</p>

<p>還記得我們要修線性代數、機率、離散數學、微積分等</p>

<p>當那時候覺得資工為什麼要學這些數學</p>

<p>不是只要會打程式就好了嗎？</p>

<p>現在終於吃到苦頭</p>

<p>在看Paper時，很多數學理論都是需要這些基礎的</p>

<p>但也沒時間後悔了，只能趕快回頭補救</p>

<hr />
<h2 id="似然函數likelihood">似然函數(Likelihood)</h2>
<hr />

<blockquote>
  <p>機率用於在已知一些參數的情況下，預測接下來的觀測所得到的結果，而似然性則是用於在已知某些觀測所得到的結果時，對有關事物的性質的參數進行估計</p>
</blockquote>

<p>關於什麼是<code class="highlighter-rouge">Likelihood</code>，什麼是<code class="highlighter-rouge">Maximum Likelihood Estimation</code></p>

<p><a href="https://zh.wikipedia.org/wiki/最大似然估计">維基百科</a>寫得非常完整，可以先去複習一下再回來看</p>

<p>但是在關於<code class="highlighter-rouge">似然函數</code>的定義，我會建議參考<a href="https://www.zhihu.com/question/54082000">這篇</a></p>

<div class="highlighter-rouge"><pre class="highlight"><code>L(θ|x) = f(x|θ)

x 是聯合樣本隨機變量X取到的值，X = x
θ 是未知參數
f 是一個密度函數，給定參數θ下關於聯合樣本值x的聯合密度函數
</code></pre>
</div>

<p>雖然<code class="highlighter-rouge">函數值</code>相等，但兩個函數是完全不同的</p>

<p>L是<code class="highlighter-rouge">對θ</code>的函數，f是<code class="highlighter-rouge">對x</code>的函數</p>

<p>也可以看成兩種不同的切入角度</p>

<p>L是給定觀測結果後，去預測參數θ</p>

<p>f則是給定參數θ，去得到結果的機率是多少</p>

<hr />

<p>假設f是<code class="highlighter-rouge">機率質量函數</code></p>

<p>我們可以寫成</p>

<div class="highlighter-rouge"><pre class="highlight"><code>L(θ|x) = P(X = x|θ)
</code></pre>
</div>

<p><strong>注意，這邊的|，表示給定θ的意思</strong></p>

<p>所以，舉例來說，在一個公平的投擲硬幣的例子中</p>

<p>前三次結果都是正面，我們記為HHH</p>

<p>所以在一般的機率下，我們已知正面發生的機率為0.5</p>

<div class="highlighter-rouge"><pre class="highlight"><code>L(p=0.5|HHH) = P(HHH|p=0.5) = 0.125
</code></pre>
</div>

<p>我們對這個式子可以有兩種解釋</p>

<ol>
  <li>在給定結果HHH時，骰子骰到正面機率為0.5的機率是0.125</li>
  <li>在給定骰子骰到正面機率為0.5時，得到結果HHH的機率為0.125</li>
</ol>

<p>所以回到觀點1，從這樣的觀點，當我們得到HHH的結果時</p>

<p>骰子骰到正面機率最有可能會是1</p>

<p>換句話說，這最有可能是一個怎麼骰到骰到正面的骰子</p>

<div class="highlighter-rouge"><pre class="highlight"><code>L(p=1|HHH) = P(HHH|p=1) = 1 * 1 * 1 = 1
</code></pre>
</div>

<p>L(p=1|HHH)等於1，大於L(p=0.5|HHH)的0.125</p>

<hr />
<h2 id="隨機變數random-variable">隨機變數(Random Variable)</h2>
<hr />

<p>離散隨機變數(discrete random variable)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>若是隨機變數X的取值是有限或可數的
X = { x1, x2, x3, ..., xn}
則稱Ｘ為離散隨機變數
</code></pre>
</div>

<p>連續隨機變數(continuous random variable)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>若隨機變數Ｘ是由全部實數或某一部分區間所組成的話
X = {x|a &lt;= x &lt;= b}, -inf &lt; a,b &lt; inf
則稱Ｘ為連續隨機變數
</code></pre>
</div>

<hr />
<h2 id="機率質量函數pmf機率密度函數pdf">機率質量函數(pmf)、機率密度函數(pdf)</h2>
<hr />

<p>關於<a href="https://zh.wikipedia.org/wiki/概率质量函数">機率質量函數</a>跟<a href="https://zh.wikipedia.org/wiki/機率密度函數">機率密度函數</a>的定義跟性質非常重要</p>

<p>但在這裡不加贅述，詳細參考提供的維基百科連結</p>

<hr />
<h2 id="機率分布離散分布與連續分布">機率分布：離散分布與連續分布</h2>
<hr />

<p>關於<a href="https://zh.wikipedia.org/wiki/概率分布#伽马分布">機率分布</a>主要分為兩種：</p>

<p>離散分布：值域是離散的，例如：擲硬幣，結果有正面與反面</p>

<p>常見的離散分布有：<code class="highlighter-rouge">二項分布</code></p>

<p>連續分布：值域是連續的，例如：人類的身高分布</p>

<p>常見的連續分布有：<code class="highlighter-rouge">常態分布</code></p>

<p>最好可以記一下每種分布所對應到的<code class="highlighter-rouge">pmf</code>或是<code class="highlighter-rouge">pdf</code></p>

<hr />
<h2 id="最大似然估計maximum-likelihood-estimation">最大似然估計(Maximum Likelihood Estimation)</h2>
<hr />

<p>了解了什麼是<code class="highlighter-rouge">似然函數(Likelihood Function)</code>之後</p>

<p>求<code class="highlighter-rouge">最大似然(Maximum Likelihood)</code></p>

<p>也就是在某一機率分布下，最有可能的參數</p>

<p>根據<a href="https://zh.wikipedia.org/wiki/最大似然估计">維基百科</a>所舉的例子</p>

<p>可以分為三種組合</p>

<ol>
  <li>離散分布，離散有限參數空間</li>
  <li>離散分布，連續參數空間</li>
  <li>連續分布，連續參數空間</li>
</ol>

<hr />

<p>第一種情況，我們的參數由於<code class="highlighter-rouge">離散而且有限</code></p>

<p>所以我們理論上能試過所有可能的機率，取最大值</p>

<hr />

<p>第二種情況：<code class="highlighter-rouge">離散分布，連續參數空間</code></p>

<p>我一開始在這邊有點疑問</p>

<p>連續的參數空間，怎麼使得結果是離散分布呢？</p>

<p>舉維基的例子來說，假設我們今天準備了無數個硬幣</p>

<p>每個硬幣擲到正面的機率p分布在0到1</p>

<p>而每個p都有對應到該機率的硬幣</p>

<p>假設今天隨機拿一個硬幣骰了100次，得到正面40次，反面60次的觀測結果</p>

<p>我們記為H=40，T=60，可以求<code class="highlighter-rouge">Likelihood</code>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>L(θ|H=40,T=60) = P(H=40,T=60|p) = C(100,40) * p^40 * (1-p)^60 (二項分布)
</code></pre>
</div>

<p>所以，接下來我們要求得<code class="highlighter-rouge">似然函式L</code>在0~1之間的最大值</p>

<p>由於L是個<code class="highlighter-rouge">連續函數</code>，我們要求得導函數為零的值，於是</p>

<div class="highlighter-rouge"><pre class="highlight"><code>C(100,40) * (40 * p^39 * (1-p)^60 - 60 * p^40 * (1-p)^59) = 0
p^39 * (1-p)^59 * ( 40 * (1-p) - 60 * p) = 0
... * (100p + 40) = 0
</code></pre>
</div>

<p>所以可以得出，p = 0, 1, 40/100</p>

<p>0, 1不可能，因為會使得L為0，所以p=40/100時是Maximum Likelihood</p>

<p>由此我們也能歸納出，二項分布的最大似然估計值為</p>

<div class="highlighter-rouge"><pre class="highlight"><code>MLE = t/N

t為正面（成功）的次數，N為總次數
</code></pre>
</div>

<p>我們再回到剛剛說的連續參數空間，為什麼卻是離散分布的問題</p>

<p>我們上述整個過程都是在對<code class="highlighter-rouge">似然函數L</code>做操作</p>

<p>而似然函數的分布是連續的沒錯，但所謂的離散指的是<code class="highlighter-rouge">值域</code>的離散</p>

<p>這邊的結果只會有正面跟反面，不像身高、智商、體重等等呈現連續分布</p>

<hr />

<p>第三種情況：<code class="highlighter-rouge">連續分布，連續參數空間</code></p>

<p>舉常態分布為例</p>

<p>我們發現到，控制的參數有兩個µ, σ^2</p>

<p>等一下做導函數時，需要分別做<code class="highlighter-rouge">偏微分</code>即可</p>

<p>另外值得一提的是，我們通常會取自然對數再求導函數</p>

<p>因為在似然函數L的值域中(0~1)，自然對數是<code class="highlighter-rouge">嚴格遞增的上凸函數</code></p>

<p>所以求似然函數的最大值跟取完自然對數後的最大值是等價的</p>

<p>這邊的計算較繁雜，可以參考<a href="https://zh.wikipedia.org/wiki/最大似然估计">維基即可</a></p>

<hr />
<h2 id="references">References</h2>
<hr />

<ol>
  <li>PRML-Chapter 2</li>
  <li>Wiki</li>
  <li>Saeed-Ghahramani-Fundamentals-of-Probability</li>
</ol>

		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/05/01/s_MLE.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>機器學習筆記</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<p><em>此文章尚未校正</em>
<em>此文章尚未完成</em></p>

<hr />
<h2 id="前言">前言</h2>
<hr />

<p>機器學習(Machine Learning)是最近非常夯的一個詞，而清大資工也在最近將機器學習納入選修課程了，可知他的重要性</p>

<p>而機器學習能應用的範圍據我所知，不僅僅能用於資工相關領域</p>

<p>相反的，幾乎各種領域都能運用這個技術，包括醫學、財經、商業、工業等等</p>

<p>這篇文章將會持續更新，我會將我過去及未來所學相關的機器學習筆記全部消化過</p>

<p>以我自己的語言作成的筆記，分享給大家</p>

<p>因為我並非專業，算是自己自學的，所以內容也許有錯誤或有說得不夠精準的地方</p>

<p>這邊主要的內容來自於Andrew Ng教授在Coursera上所開的課程</p>

<p>其中有一個專業向度為<a href="https://www.coursera.org/specializations/deep-learning">深度學習向度</a></p>

<p>裡面包含了五堂課分別為：</p>

<ol>
  <li>Neural Network and Deep Learning</li>
  <li>Improving Deep Neural Networks: Hyperparameters tuning , Regularization, and Optimization</li>
  <li>Stucturing Machine Learning Project</li>
  <li>Convlutional Neural Network</li>
  <li>Sequnce Models</li>
</ol>

<p>在下一小節的目錄，會簡單列出小標，代表我覺得重要的小概念</p>

<p>看到小標心裡應該要能浮現相關的概念跟算式</p>

<p>能不能清楚的向別人解說這個概念</p>

<p>請不吝來信指正我的錯誤: <strong>a5560648@gmail.com</strong></p>

<hr />
<h2 id="目錄">目錄</h2>
<hr />

<ol>
  <li>Neural Network and Deep Learning
 a. logistic regression
 b. gradient descent
 c. vectorization
 (d. numpy)
 e. neural network
 f. activation function
 g. gradient descent for nerual network
 h. backpropagation
 i. random initialization
 j. forward-propagation and backward-propagation
 k. parameters vs. Hyperparameters</li>
  <li>Improving Deep Neural Networks: Hyperparameters tuning , Regularization, and Optimization
 a. bias/variance
 b. train/dev/test dataset
 c. regularization
 d. dropout regularization, (keep-probability)
 e. L2 Regularization
 f. data augmentation
 (f-2. Comparision of different regularization methods: …, early-stopping)
 g. normalizing inputs
 h. weight initialization for deep learning neural network (Xaiver Initialization or He Initialization)
 i. Gradient Checking
 j. mini-batch vs. batch vs. stochastic
 （j-2. batch-size, power of 2)
 （j-3. what’s epoch）
 k. exponentially weighted averages
 (k-1. increasing or decreasing ß will causes what kind of effect) - ß值越大，就會越平滑，並且越偏向右邊，因為看的歷史更多
 l. bias correction in exponentially weighted averages
 m. gradient descent with monentum
 (m-1. how does it work? - to redcue the oscillation in gradient descent. By looking back the history(kind of average))
 n. RMS prop
 (n-1. how does it work? ) - intend to make the smoother part to move fast, steaper part to move slower
 o. Adam optimization algorithm(combining the advantage of RMS prop and monetum)
 p. learning rate decay(There are various ways to do so)
 q. appropriate searching scale for hyperparameters(for examples, learning rate alpha in log scale)
 r. panda vs. caviar
 s. normalize activations in a network(how to apply normalization in a neural network)
 t. the batch norm step happens between z and a(for each layer we have gama and beta), and we can eliminate b, since we have already had beta.（works fine with RMS prpo, Adam ..）
 u. Covariate shift, (the batch norm eliminate the effect of the previous layer change, and make the neural netowrk more stable)(have a slight regularization effect)
 v. Batch Norm at test time(since we don’t have batch in test time, i.e. only one test example, so we could use expontentially weighted average to estimate µ and ∂) 
 )
 w. sofmax(sofmax activation function) -&gt; need to take a vector as input and out a vector which represents prob
 (w-1. first, apply activation function, like e^(x), and then normalize it as output)
 x. sofmax regression generalizes logistic regression to C classes
 y. tensorflow(plz get to know some basic produres we will use in TensorFlow)
 z.</li>
  <li>Stucturing Machine Learning Project</li>
  <li>
    <p>Convolutional Neural Network
 a. edge detection(vertical edge detection, horizontal edge detection)
 (a-1. using a filter to do convolution)
 b. Use DL(back-prop) to learn filter’s parameters and do convolution
 c. padding, why?(1. don’t want image shrink, 2. use the corner pixel more)
 (c-1. valid convolution(no padding), nxn * fxf -&gt; n-f+1)
 (c-2. same convolution, pad so that the output size is the same as the input size)
 d. strided convolution(why?)
 e. convolution over volumn(just similar process of 2D image, however, we can apply many different kinds of filters and combine them together to get multilayers output.)
 f. One layer of Convolutional neural network, how does the parameters look like in Convolution Neural Network
 (f-1. notation of )
 g.</p>

    <p>week-1-ex: https://hub.coursera-notebooks.org/user/cfcnolvswxoldpqunmvrbt/notebooks/week1/Convolution%20model%20-%20Step%20by%20Step%20-%20v2.ipynb</p>
  </li>
  <li>Sequnce Models</li>
</ol>

<hr />
<h2 id="什麼是機器學習跟深度學習又有什麼差異">什麼是機器學習？跟深度學習又有什麼差異？</h2>
<hr />

<hr />
<h2 id="常常聽到人家說調參數是什麼意思呢">常常聽到人家說「調參數」，是什麼意思呢？</h2>
<hr />

<hr />
<h2 id="訓練集training-setdeveloping-set測試集testing-set怎麼分">訓練集(training set)、(developing set)、測試集(testing set)怎麼分？</h2>
<hr />

<ol>
  <li>training set, developing set, testing set的意義</li>
  <li>一個資料集(dataset)，如何切分</li>
  <li>實際例子以及在python上如何操作</li>
</ol>

<hr />
<h2 id="bias-variance-tradeoff">bias-variance tradeoff</h2>
<hr />

<ol>
  <li>overfitting及underfitting</li>
  <li>high-variance及high-bias</li>
  <li>tradeoff</li>
  <li>從error觀察model有可能存在問題</li>
</ol>

<p>overfitting顧名思義，是這個model訓練過頭了，雖然在training set得到的error很低</p>

<p>但是在developing set的error卻很高</p>

<p>換句話說，就是你的model因為訓練過頭，變成只適用於你給的training data，換成沒看過的data，預測失敗的比率就很高</p>

<p>underfitting則跟overfitting相反，在training set的時候error就很高了</p>

<p>代表你的model訓練不夠，所以沒辦法正確的預測結果，通常underfitting的情況下</p>

<p>training set error跟developing set error兩者都會很高</p>

<p>再來我們談high-variance跟high-bias</p>

<p>high-variance基本上可以視作overfitting，過度fit data，所以畫出來的decision boundary會是一條很複雜的曲線</p>

<p>當看到新的data，預測錯誤的機率高</p>

<p>high-bias則是可以視作underfitting，因為訓練不夠或者有錯誤，導致連在training set的data都預測不準</p>

<p>所以簡單來說：</p>

<table>
  <tbody>
    <tr>
      <td>overfitting</td>
      <td>high-variance</td>
      <td>過度訓練</td>
      <td>train set error低</td>
      <td>dev set error高</td>
    </tr>
    <tr>
      <td>underfitting</td>
      <td>high-bias</td>
      <td>訓練不夠</td>
      <td>train set error高</td>
      <td>dev set error高</td>
    </tr>
  </tbody>
</table>

<p>而回歸這個部分的標題: bias-variance tradeoff，為什麼說tradeoff呢？</p>

<p>因為其實bias跟variance應該是看作為一種「傾向」，當我們往high-bias那一方走時，同時variance就越來越低</p>

<p>從以下的例子來看：</p>

<p>|A|B|C|
Train set error|1%|15%|15%|
Dev set error|11%|16%|30%|
Base error: ~0</p>

<p>這這裡很重要的一個觀念是Base Error，也就是在最好的model下、或者人直接觀察的情況下的error有多少</p>

<p>比如說判別一個圖片中的人，我們用人眼觀察幾乎能百分之百辨認出來，所以Base error就趨近於零</p>

<p>但是若是像辨別一個句子主不主觀，每個人做出來的結果可能就有差，而也有無法辨別出來的人，這是後Base Error就不等於零</p>

<p>而假設今天Base Error等於5%好了，那我們做出來一個model雖然他的error等於6%，但這樣的結果卻是極好的了</p>

<p>換句話說，我們在觀察model的error時，應該考量Base Error來分辨Model的好壞</p>

<p>回到這裡，A的traing set error是1%，相對於Base Error也算是相當好的結果，而dev set error卻很高</p>

<p>所以我們說A是high-variance</p>

<p>B則是training set error跟dev set error都很高，所以B較有可能是high-bias</p>

<p>最後C也是traing set error跟dev set error都很高，但dev set error又比train set error高出許多</p>

<p>這時候不只是訓練不夠，而是訓練錯誤、訓練錯方向，所以導致high-bias&amp;high-variance</p>

<hr />
<h2 id="regularization">Regularization</h2>
<hr />

<hr />
<h2 id="來源reference">來源(Reference)</h2>
<hr />

<p><em>Coursera</em></p>
<ul>
  <li>Machine Learning:</li>
  <li>Deeping Learning Specialization: https://www.coursera.org/specializations/deep-learning</li>
</ul>

<p><em>Github</em></p>
<ul>
  <li>Kulbear/deep-learning-course: https://github.com/Kulbear/deep-learning-coursera/blob/master/Neural%20Networks%20and%20Deep%20Learning/Deep%20Neural%20Network%20-%20Application.ipynb</li>
  <li>shenweichemn: https://github.com/shenweichen/Coursera</li>
</ul>

<p><em>Userful Blog</em></p>


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/03/20/%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98(ML-note).html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>React.js筆記</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="前言">前言</h2>
<hr />

<p>由於最近在進行的專案中，我打算使用<code class="highlighter-rouge">React.js</code>來完成前端的部分</p>

<p>所以開始學習<code class="highlighter-rouge">React.js</code>，當開始學習後</p>

<p>各式各樣的<code class="highlighter-rouge">名詞</code>跟<code class="highlighter-rouge">套件</code>真是嚇壞我</p>

<p>React.js, MVC, JSX, Flux, Redux, webpack, node.js, express, bootstrap, sass…等等族繁不及備載</p>

<p>總之，我想要一步步慢慢地了解這些</p>

<p>這篇文章可能會有很多錯誤，因為我是使用自己的觀點去解釋</p>

<p>請不吝告訴我，真理是越辯越明，希望我們能互相學習: <code class="highlighter-rouge">a5560648@gmail.com</code></p>

<hr />
<h2 id="目錄">目錄</h2>
<hr />

<ol>
  <li>React.js是什麼</li>
  <li>render()</li>
  <li>什麼時候用function，什麼時候用class</li>
  <li>JSX語法</li>
  <li>監聽事件寫法</li>
  <li>父組件與子組件的溝通</li>
  <li>在React.js中(在JSX語法中)，要注意的HTML屬性寫法</li>
  <li>驗證傳入物件類別(Verify Type)</li>
  <li>習慣的命名規則</li>
</ol>

<p><em>2018.3.7</em></p>

<hr />
<h2 id="reactjs是什麼">React.js是什麼？</h2>
<hr />

<p>以前傳統的前端撰寫方式，是要先寫好HTML，然後再由JavaScript做操作</p>

<p>但是這樣的方式導致維護不易，並且相似的元件<code class="highlighter-rouge">重用性</code>不高</p>

<p>而React.js的理念則是建立一層<code class="highlighter-rouge">虛擬的組件邏輯</code>來管理HTML DOM元素</p>

<p>HTML標籤則退居僅剩<code class="highlighter-rouge">呈現UI</code>的功能，<code class="highlighter-rouge">架構UI</code>的功能則改由React.js來做操作</p>

<p>以下是從<a href="https://exma-square.gitbooks.io/mobious-cookbook/content/Front-End/ReactJS/Intro.html">mobious-cookbook</a>所節錄的React.js介紹</p>

<blockquote>
  <p>為什麼需要React.js
基於 HTML 的前端 UI 開發正變得越來越複雜，其本質問題基本上都可以歸結於如何將後端與使用者輸入的操作資料能夠動態且高效的反映到複雜的 UI 上，並且有系統的進行前端的資料管理以及測試。而來自 Facebook 的 React 正是完全根據此問題而生的一個解決方案。相較於傳統的前端開發，React 開闢了一個相當另類的途徑，實現了前端 UI 的高效率、高性能開發</p>
</blockquote>

<blockquote>
  <p>React.js與傳統前端開發方法比較
在傳統的前端開發模式中，HTML 只扮演了「定義 UI 最初的基礎 DOM 結構」的角色，所有在 JavaScript 中進行的 DOM 操作都是基於最初定義好的 DOM 再另外堆疊上去的變更，這讓前端 UI 程式碼的執行結果變得難以預測與維護。而 React 希望讓 HTML 退居為建構 UI 的小細胞，並在其之上建構一層虛擬的組件邏輯來管理 UI，這讓前端 UI 程式碼的的可預測性和可維護性大幅提升，這正是 React 最有價值之處 ── 聲明式的，直觀的定義方式</p>
</blockquote>

<p>而在React.js中的那層虛擬組件邏輯稱為<code class="highlighter-rouge">Virtual DOM</code>，在<code class="highlighter-rouge">Virtual DOM</code>中管理著UI的資料及邏輯</p>

<p>當UI發生改變時，React能根據新的UI狀態，重新<code class="highlighter-rouge">渲染</code>出新的DOM元素</p>

<p>也因此React可以避免DOM很多複雜的狀態處理，工程師只需專心撰寫UI的定義還有邏輯即可</p>

<p>最後，根據我自己的理解，如果用一句話來表示React，我會說</p>

<blockquote>
  <p>React是導入物件導向到DOM中，並且提供高效的Diff演算法來即時渲染出新的DOM</p>
</blockquote>

<hr />
<h2 id="render方法">render()方法</h2>
<hr />

<p>在React中，我們可以定義自己的<code class="highlighter-rouge">組件(class)</code></p>

<p>而在之中一定要有<code class="highlighter-rouge">render()</code>方法，定義了當這個組件被使用時</p>

<p>會轉化成什麼樣的UI呈現</p>

<div class="highlighter-rouge"><pre class="highlight"><code>render(){
	return(
		&lt;div&gt;
			&lt;p&gt;Hello&lt;/p&gt;
		&lt;/div&gt;
	)
}
</code></pre>
</div>

<p>例如以上的例子，當這個組件被使用時，就會以那樣的HTML標籤呈現在頁面上</p>

<p>有一點要注意的是，在render()方法中，回傳的內容<code class="highlighter-rouge">必須以一個外層的JSX元素包覆起來</code></p>

<p>這樣的寫法其實就是<code class="highlighter-rouge">JSX語法</code>，是一種語法糖衣(Syntactic Suger)，在編譯過程會被轉換成JavaScript語法</p>

<hr />

<p>我們知道React會即時根據組件的狀態改變，而重新渲染組件，那這件事情是如何做到的呢？</p>

<p>我們在每個組件中，可以<code class="highlighter-rouge">在建構(constructor)中</code>定義<code class="highlighter-rouge">狀態(state)</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>constructor(){
	super()
	this.state = {
		money: 0,
		active: false 
	}
}
</code></pre>
</div>

<p>上述的例子包含兩個狀態money跟active，而我們可以藉由<code class="highlighter-rouge">setState()</code>這個函式來更新狀態</p>

<p>當<code class="highlighter-rouge">setState()</code>被呼叫時，<code class="highlighter-rouge">render()</code>方法也會重新啟動，進而重新渲染組件</p>

<hr />
<h2 id="什麼時候用function什麼時候用class">什麼時候用function，什麼時候用class</h2>
<hr />

<p>而如果只是使用JSX語法呈現DOM元素，其實只用<code class="highlighter-rouge">function</code>也做得到</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const MyComponent = (props) =&gt; {
    return (
      &lt;div&gt;&lt;/div&gt;
    );
}
</code></pre>
</div>

<p><code class="highlighter-rouge">props</code>是指使用這個組件時，所傳入的屬性，也就是父組件傳給子組件的資訊</p>

<p>等等會有更詳細的解說</p>

<p>所以，什麼時候該使用<code class="highlighter-rouge">function</code>，什麼時候該使用<code class="highlighter-rouge">class</code>呢？</p>

<p>當我們需要比較複雜的組件時，例如有state的變化、state的不同影響組件的呈現方式等</p>

<p>因為<code class="highlighter-rouge">function</code>中沒有儲存state，所以這種情況下，應該使用<code class="highlighter-rouge">class</code>比較好</p>

<p><a href="https://stackoverflow.com/questions/36097965/react-when-to-use-es6-class-based-components-vs-functional-es6-components">stack上的問答</a></p>

<hr />
<h2 id="jsx語法">JSX語法</h2>
<hr />

<p>節錄至<a href="https://exma-square.gitbooks.io/mobious-cookbook/content/Front-End/ReactJS/Intro.html">mobious-cookbook</a></p>

<blockquote>
  <p>JSX 並不是一個新的語言，他更像是一種幫助開發體驗的語法糖衣。經由像是 Babel 這樣的轉碼器，JSX 會被編譯成原生 JavaScript 程式碼，才能夠在瀏覽器上順利運作。</p>
</blockquote>

<hr />
<h2 id="監聽事件寫法">監聽事件寫法</h2>
<hr />

<ol>
  <li>on* event</li>
  <li>event</li>
  <li>bind</li>
  <li>this</li>
</ol>

<p>首先，我們直接來看一個範例</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Header() extends Component{
	...
	handleClick(event, message){
		console.log(event.target.innerHTML)
		console.log(this.props.index)
		console.log(message)
	}
	render(){
		return({
			&lt;div&gt;
				&lt;h1 onClick={this.handleClick.bind(this, 'Hello!')}&gt;&lt;/h1&gt;
			&lt;/div&gt;
			})
	}
}
</code></pre>
</div>

<p>上述例子，我們用<code class="highlighter-rouge">onClick</code>這個屬性定義了監聽事件，在React中定義了許多不同的事件</p>

<p>關於總共有哪些監聽事件能在React中使用，可以參考<a href="https://reactjs.org/docs/events.html#supported-events">這裡</a></p>

<p>所以當我們點擊這個標籤時，就會執行我們自己定義的<code class="highlighter-rouge">handleClick</code>事件</p>

<p>在<code class="highlighter-rouge">handleClick</code>中，預設會傳入一個event，我們能透過<code class="highlighter-rouge">event.target</code>來取得被點擊的DOM元素</p>

<p>所以像這裡<code class="highlighter-rouge">event.target.innerHTML</code>，即是獲得<code class="highlighter-rouge">h1</code>標籤的HTML內容</p>

<p>另外，這邊我們還使用了bind(this)的原因是，當我們執行<code class="highlighter-rouge">this.handleClick</code>，在這個函式內並不知道this是誰</p>

<p>然後，在大多數的情況下，我們需要在這個函式中調用到<code class="highlighter-rouge">this</code>的資料，像是<code class="highlighter-rouge">this.state</code>和<code class="highlighter-rouge">this.props</code>等</p>

<p>所以我們必須綁定<code class="highlighter-rouge">this</code>到這個函式之中</p>

<p>而除了<code class="highlighter-rouge">event</code>跟<code class="highlighter-rouge">this</code>之外，我們還能自己傳入想要的參數到函式中</p>

<p>像是上述的例子就是傳入一個<code class="highlighter-rouge">字串</code></p>

<p>這樣的寫法就是一個常用的處理事件的架構</p>

<hr />
<h2 id="父組件與子組件的溝通">父組件與子組件的溝通</h2>
<hr />

<ol>
  <li>props與handleEvent()</li>
</ol>

<p>當我們寫好一個組件之後，他能被其他組件所使用，而使用它的組件我們稱為父組件</p>

<div class="highlighter-rouge"><pre class="highlight"><code>render(){
	return({
		&lt;MyComponent /&gt;
		})
}
</code></pre>
</div>

<p>而一個組件常常並不是只是固定的呈現方式，通常提供一些客製的選項</p>

<p>可以依據傳入的參數不同，有不同的使用或呈現方式</p>

<p>而參數傳入的方式就是透過像設定HTML屬性的方法設定</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;MyComponet 
	type="text"
	data={this.state.data}
/&gt;
</code></pre>
</div>

<p>而我們在子組件，就能透過<code class="highlighter-rouge">this.props.*</code>來取得資料</p>

<p>然後這樣的過程，只是由父組件對子組件單向的傳送資料</p>

<p>我們也能透過設定<code class="highlighter-rouge">回調函數(callback function)</code>的方式來從子組件傳送資料回父組件</p>

<p>例如以下的例子，一個父組件中有好幾個子組件，所以當其中某個子組件被點擊之後，要能回傳編號回父組件</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#父組件
...
handleClick(index){
	console.log(index)
}
render(){
	return({
		&lt;div&gt;
			&lt;MyComponent 
				index=1
				onClick={this.handleClick.bind(this)}
			/&gt;
			&lt;MyComponent 
				index=2
				onClick={this.handleClick.bind(this)}
			/&gt;
		&lt;/div&gt;
	})
}

#子組件
handleClick(event){
	if(this.props.onClick){
		this.props.onClick(this.props.index)
	}
}
render(){
	return({
		&lt;div&gt;
		&lt;h1 onClick={this.handleClick.bind(this)}&gt;Click Here!&lt;/h1&gt;
		&lt;/div&gt;
	})
}
</code></pre>
</div>

<p>這個例子剛好也能複習監聽事件的寫法，只有在原始的<code class="highlighter-rouge">HTML標籤</code>中所調用的監聽事件，才會預設傳入<code class="highlighter-rouge">event</code></p>

<p>像在父組件我們也在子組件的屬性中使用了<code class="highlighter-rouge">onClick</code>，並且事件觸發時同時也會呼叫本地事件<code class="highlighter-rouge">handleClick</code></p>

<p>但是此時handleClick中並沒有傳入event，而其實我們也可以不用以<code class="highlighter-rouge">on</code>開頭命名，只是這樣比較符合直觀</p>

<p><code class="highlighter-rouge">父組件的handleClick</code>接收的參數是決定了子組件能夠傳回哪些資訊回來給父組件</p>

<p>這裡我們需要的是子組件的編號，所以傳回來的參數是<code class="highlighter-rouge">index</code></p>

<p>接下來，讓我們看回子組件，當我們按了<code class="highlighter-rouge">Click!here</code>，即會觸發<code class="highlighter-rouge">子組件的handleClick</code></p>

<p>首先先驗證父組件是否有定義<code class="highlighter-rouge">處理onClick事件的函式</code>，如果有的話，我們就能調用那個函式</p>

<p>在這裡我們能調用函式，並且回傳<code class="highlighter-rouge">this.props.index</code>，也就是當初父組件定義的index編號回父組件</p>

<p>進而讓父組件知道是哪個子組件被點擊了</p>

<hr />
<h2 id="在reactjs中在jsx語法中要注意的html屬性寫法">在React.js中(在JSX語法中)，要注意的HTML屬性寫法</h2>
<hr />

<p>在JSX語法中，要特別注意<code class="highlighter-rouge">class</code>跟<code class="highlighter-rouge">for</code>，在JSX語法中分別為<code class="highlighter-rouge">className</code>跟<code class="highlighter-rouge">htmlFor</code></p>

<p>原因是因為<code class="highlighter-rouge">class</code>跟<code class="highlighter-rouge">for</code>在JavaScript中是保留字，所以要避免</p>

<p>而當JSX最後被渲染成DOM後，就會轉換回<code class="highlighter-rouge">class</code>跟<code class="highlighter-rouge">for</code>了</p>

<hr />
<h2 id="驗證傳入物件類別verify-type">驗證傳入物件類別(Verify Type)</h2>
<hr />

<p><a href="http://huziketang.com/books/react/lesson24">為什麼要使用PropTypes</a></p>

<p><a href="https://reactjs.org/docs/typechecking-with-proptypes.html">官方文檔對PropTypes的說明</a></p>

<p>大家可以先參閱這兩篇文章，對<code class="highlighter-rouge">PropTypes</code>有一些基本的了解</p>

<p>當我們定義好一個組件，我們可能預設父組件會傳入哪些資料</p>

<p>所以因此直接在子組件中使用那些資料</p>

<p>但是實際上被使用時，我們不知道使用者會傳入哪些資料，如果不是傳入正確的資料</p>

<p>也不會有錯誤訊息，但最後的結果可能並不是我們預設的呈現效果</p>

<p>所以我們能先設定<code class="highlighter-rouge">PropTypes</code>來規範這個組件要怎麼被使用</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Greeting extends React.Component {
  render() {
    return (
    	&lt;div&gt;
     		&lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;
     		&lt;p&gt;Age: {this.props.age}&lt;/p&gt;
     		&lt;p&gt;Sex: {this.props.sex}&lt;/p&gt;
     	&lt;/div&gt;
    );
  }
}
Greeting.defaultProps = {
  name: 'Stranger'
  age: PropTypes.number
  sex: PropTypes.element.isRequired
};
</code></pre>
</div>

<p>能夠指定<code class="highlighter-rouge">Type</code>，<code class="highlighter-rouge">是否必須</code>，<code class="highlighter-rouge">預設值</code>等等</p>

<hr />
<h2 id="習慣的命名規則">習慣的命名規則</h2>
<hr />

<ol>
  <li>每個物件一個檔案，並且以大寫作為開頭</li>
  <li>私有方法用<code class="highlighter-rouge">_</code>開頭</li>
  <li>事件監聽方法，用<code class="highlighter-rouge">handle</code>開頭</li>
  <li>使用<code class="highlighter-rouge">Camel</code>命名規則</li>
</ol>

<hr />
<h2 id="參考來源references">參考來源(References)</h2>
<hr />

<ol>
  <li><a href="https://stackoverflow.com/questions/36097965/react-when-to-use-es6-class-based-components-vs-functional-es6-components">When to use class vs. function</a></li>
  <li><a href="https://exma-square.gitbooks.io/mobious-cookbook/content/Front-End/ReactJS/Intro.html">mobious-cookbook</a></li>
  <li><a href="https://blog.techbridge.cc/2016/04/21/react-jsx-introduction/">一看就懂的 JSX 簡明入門教學指南</a></li>
  <li><a href="http://huziketang.com/books/react/lesson1">React.js小书</a></li>
</ol>

<p><em>2018.3.07</em></p>


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/03/07/React.js%E7%AD%86%E8%A8%98.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>SVM Classifier</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="前言">前言</h2>
<hr />

<p>其實在上學期看Couresa上的機器學習課程中，就已經有提到SVM了</p>

<p>不過本人腦袋不太靈光，看過就忘了</p>

<p>現在在看論文時，看到這個似曾相似的詞，腦中卻沒有浮現它的運作原理</p>

<p>於是決定花點時間再重新好好學習它吧！</p>

<hr />
<h2 id="svmsupport-machine-vector基本介紹">SVM(Support Machine Vector)基本介紹</h2>
<hr />

<p>SVM屬於一種監督式學習(Supervised Learning)，跟</p>

<hr />
<h2 id="和logistic-regression與neural-network的比較">和Logistic Regression與Neural Network的比較</h2>
<hr />

<hr />
<h2 id="svm原理">SVM原理</h2>
<hr />

<ol>
  <li>How does SVM work?</li>
  <li>Large Margin Classifier</li>
</ol>

<p>我們可以把SVM看成簡化版的Logistic Regression</p>

<p>為什麼這樣說呢？首先先從Logistic Regression的cost function說起</p>

<p><img src="/res/math/CodeCogsEqn.svg" alt="img" /></p>

<p>而我們最後是要最小化所有的cost總和，所以改寫成這樣</p>

<p><img src="/res/math/CodeCogsEqn-2.svg" alt="img" /></p>

<p>而SVM做的，就是將其中計算cost的function，改成一個較簡單的function</p>

<p>從以下的圖來解說，本來是log，是一種漸進的圖形，而SVM改成使用逼近原本圖形的直線</p>

<p>這樣可以達到節省計算資源的目的</p>

<p>所以讓我們來看SVM的公式長怎樣，由於這是一個optimization的式子，因此對於式子前的乘積我們可以省略</p>

<p>最後得出的optimized value應該要相同</p>

<p><img src="/res/math/CodeCogsEqn-3.svg" alt="img" /></p>

<p>其中，C代表的是調整weight的參數，cost0跟cost1則是SVM用於逼近的函式</p>

<p>Large Margin Classifier</p>

<p>原理是要從「內積」想，我們從SVM帶出的兩個facts來想</p>

<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>p(i) *</td>
          <td> </td>
          <td>theta</td>
          <td> </td>
          <td>&gt;= 1   if y(i) = 1</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>p(i) *</td>
          <td> </td>
          <td>theta</td>
          <td> </td>
          <td>&lt;= -1. if y(i) = 0</td>
        </tr>
        <tr>
          <td>ps. theta^T .* x(i) = p(i) *</td>
          <td> </td>
          <td>theta</td>
          <td> </td>
          <td> </td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<p>所以，假設今天我的decision boundary的margin很小</p>

<table>
  <tbody>
    <tr>
      <td>那相對的p(i)就會很小，那要達成上面兩式的要求，只能是</td>
      <td> </td>
      <td>theta</td>
      <td> </td>
      <td>很大</td>
    </tr>
  </tbody>
</table>

<p>但這樣又會regularization term太大，所以在要求最小值的條件下</p>

<p>SVM就能夠達到Large Margin的效果</p>

<hr />
<h2 id="實際運用svm">實際運用SVM</h2>
<hr />

<hr />
<h2 id="來源references">來源(References)</h2>
<hr />

<p>*Machine Learning Course by Andrew Ng on Couresa: *</p>

		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/03/05/SVM-Classifier.html">Readmore</a>
	</div>
</div>

	<!-- OK -->

<div class="view-window view-color round-corner max-height-350">
	<div class="view-section-attr view-section-title text-left text-bg-color round-corner" >
		<p>npm套件管理系統</p>
	</div>
	<div class="view-section-attr view-section-content text-left text-bg-color round-corner max-height-200">
		<p>
			<hr />
<h2 id="前言">前言</h2>
<hr />

<p>由於我最近在學習<code class="highlighter-rouge">React.js</code>跟<code class="highlighter-rouge">node.js</code>，於是開始接觸到<code class="highlighter-rouge">npm</code>這個詞</p>

<p>常常有時候在安裝軟體時，也會看到這行指令</p>

<p>但總是沒有認真地去理解，為什麼要用<code class="highlighter-rouge">npm</code>？</p>

<p>所以今天好好的整理一篇文章來學習<code class="highlighter-rouge">npm</code>到底是什麼</p>

<hr />
<h2 id="npm是什麼為什麼要知道它">npm是什麼？為什麼要知道它？</h2>
<hr />

<p><code class="highlighter-rouge">npm</code>是一個套件管理系統，用來管理專案下使用的套件，並且可以讓JavaScript工程師們分享和使用彼此的套件</p>

<p>有了<code class="highlighter-rouge">npm</code>之後，我們管理跟使用套件變得很容易</p>

<p>只要下簡單的指令，就能夠在npm server上分享或者使用套件</p>

<p>專案下的套件(packages)會放在<code class="highlighter-rouge">node_modules</code>的資料夾下</p>

<p>此外，也能夠自訂自己的套件，並且在<code class="highlighter-rouge">package.json</code>檔案中，提供基本訊息像是：作者、版本號、名稱等等</p>

<hr />
<h2 id="npm常用指令">npm常用指令</h2>
<hr />

<p>查詢<code class="highlighter-rouge">npm</code>命令列表</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm help
</code></pre>
</div>

<p>查詢各個命令的基本用法</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm -l
</code></pre>
</div>

<p>初始化一個新的<code class="highlighter-rouge">package.json</code>文件</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm init
</code></pre>
</div>

<p>查詢每個package的基本資料</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm info {package-name}
</code></pre>
</div>

<p>找出放全局包(<code class="highlighter-rouge">global packages</code>)的路徑</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm root -g
</code></pre>
</div>

<p>列出當前專案所有的packages</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm list 
npm list -global
</code></pre>
</div>

<p>安裝package「到目前專案」，注意，npm預設本地模式，也就是每次不同專案，都必須重新安裝要用到的packages</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install {package-name}
npm install -g {package-name} # global mode
</code></pre>
</div>

<p>也能直接用<code class="highlighter-rouge">github</code>代碼庫地址</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install {http://github.com/~}
</code></pre>
</div>

<p><code class="highlighter-rouge">dependencies</code>，也就是專案中會用到的其他工具包列表</p>

<p>分為兩種：<code class="highlighter-rouge">dependencies</code>(依賴)跟<code class="highlighter-rouge">devDependencies</code>(開發依賴)</p>

<p><code class="highlighter-rouge">dependencies</code>下的package指的是，別人如果要使用現在這個package，也必須安裝的pacakges，就像是堆積木一樣</p>

<p>現在這個package是基於<code class="highlighter-rouge">dependencies</code>下其他的packages所構成的</p>

<p>所以當要使用現在這個package，就要先連下面的packages都安裝好</p>

<p>而<code class="highlighter-rouge">devDependencies</code>(開發依賴)指的是只有在開發環境下用到的別的packages</p>

<p>意味著別人使用這個package，並不需要安裝</p>

<p>舉例來說，假設你今天買了一台iphone，如果要順利使用iphone，手機裡面那些零件是必備的，所以也要包含在iphone中</p>

<p>但是假設Apple說測試過iphone被車子碾過也不會壞掉</p>

<p>你要順利使用iphone，不用那台車子也可以順利使用，這是因為車子是用來開發時測試的</p>

<hr />

<p>我們安裝packages時，可以選擇要將所安裝的package歸類到dependencies或者devDependencies</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install {package-name} --save # dependencies
npm install {package-name} --save-dev # devDependencies
</code></pre>
</div>

<p>安裝後，我們可以很輕易的來使用這些packages，透過<code class="highlighter-rouge">require</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>var package = require('{package-name}')
</code></pre>
</div>

<p>在<code class="highlighter-rouge">package.json</code>中，有一個欄位是<code class="highlighter-rouge">scripts</code>，裡面代表我們能夠運行的腳本</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm run {script-name}
</code></pre>
</div>

<p>這裡是我目前某個專案的<code class="highlighter-rouge">package.json</code>檔節錄</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"scripts": {
"start": "react-scripts start",
"build": "react-scripts build",
"test": "react-scripts test --env=jsdom",
"eject": "react-scripts eject"
}
</code></pre>
</div>

<p>所以，當我們運行</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm run build
</code></pre>
</div>

<p>實際上運行的是</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm run react-scrips build
</code></pre>
</div>

<p>此外，npm中每個腳本有兩個hooks，分別為<code class="highlighter-rouge">pre-</code>跟<code class="highlighter-rouge">post-</code>，在執行腳本時，會先檢查有沒有<code class="highlighter-rouge">pre-</code>，有的話會先跑<code class="highlighter-rouge">pre-</code></p>

<p>一樣的，運行完也會檢查有沒有<code class="highlighter-rouge">post-</code></p>

<p>舉例來說：當我們跑</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm run build
</code></pre>
</div>

<p>如果scripts中有「prebuild」，那就會先跑prebuild</p>

<hr />

<p>在npm中還有一個很有用的指令：<code class="highlighter-rouge">npm link</code></p>

<p>原本不能直接對<code class="highlighter-rouge">global package</code>使用<code class="highlighter-rouge">require</code>，但如果使用<code class="highlighter-rouge">link</code>指令將global package指到存放local package的位置後</p>

<p>就能夠打破此限制</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm link {package-name} {position of the local package} {position of the global package}
</code></pre>
</div>

<hr />
<h2 id="npm可能潛藏的問題">npm可能潛藏的問題</h2>
<hr />

<p>根據維基百科的內容：</p>

<blockquote>
  <p>npm的模組以「先到先得」的原則註冊，各模組作者不會發生混亂。然而一旦有人撤回自己釋出的模組，那麼不僅會使依賴那個模組的專案出現問題，還會帶來安全風險。例如有一個模組叫做「left-pad」，其中只有一個字串對齊的功能。但是，當作者把它從registry裡面移除之後，許多模組便無法正確構建</p>
</blockquote>

<p>在npm中，我們建構package時，就像是堆積木一樣</p>

<p>大部分時候我們需要依賴別人已經做好的package，在這之上完成更大的package</p>

<p>但如果今天把積木底層的一塊抽開，整座積木就變得不穩定，甚至可能會倒塌</p>

<p>此外，由於大家都能夠簡單在npm上發布package，在npm上可能存在惡意的package，並且不被注意到廣泛地被使用到新的package中</p>

<p>就像病毒擴散一樣，更多的package又建構在受污染的package上，因而造成安全性問題</p>

<p>下面這篇文章的作者就說明了npm潛藏的問題</p>

<p>假設今天有一段盜用信用卡的程式碼偽裝成有用的小工具，並且利用npm平台擴散出去</p>

<p>便能夠藉此取得全球上千萬人的信用卡資料，有興趣的人可以參考<a href="https://medium.com/@CQD/翻譯-我是這樣拿走大家網站上的信用卡號跟密碼的-991cb6c4631e">這篇文章</a></p>

<hr />
<h2 id="來源references">來源(References)</h2>
<hr />

<p><em>wiki: https://zh.wikipedia.org/wiki/Npm</em></p>

<p><em>RUNOOB.COM: http://www.runoob.com/nodejs/nodejs-npm.html</em></p>

<p><em>Never_yu’s Blog: https://neveryu.github.io/2017/04/10/npm/</em></p>

<p><em>CQD&amp;hackermoon</em>:</p>

<ol>
  <li>https://medium.com/@CQD/翻譯-我是這樣拿走大家網站上的信用卡號跟密碼的-991cb6c4631e</li>
  <li>https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5</li>
</ol>


		</p>
	</div>		
	<div class="view-section-attr view-section-readmore text-center text-bg-color round-corner">
		<a href="/cs/2018/03/03/npm%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%B5%B1.html">Readmore</a>
	</div>
</div>

		</div>
		<div>
		</div>
	</div>
</div>
		</main>
		<footer class="footer">
			<!-- No -->

<!--This is the footer of the website-->

<div class="footer-window container-fluid footer-color">
	<div class="row text-center">
		<div class="footer-view footer-info col-md-4 text-left">
				<div class="text-left">
					<i class="fab fa-github-square account-icon"></i> 
					<span class="account">@polyline</span>
				</div>
				<div>
					<i class="fab fa-instagram account-icon"></i> 
					<span class="account">@__tsu__pei</span>
				</div>
				<div>
					<i class="fas fa-envelope account-icon" ></i> 
					<span class="account">a5560648(@gmail)</span>
				</div>
		</div>
		<div class="footer-view footer-words col-md-4">
			<p>快樂有很多種</p>
			<p>平凡的快樂、頹廢的快樂、成就的快樂</p>
			<p>追尋自己想要的快樂</p>
		</div>
		<div class="footer-view footer-license col-md-4">
			<p>Version 0.0.4</p>
		</div>
	</div>
</div>

<!--
log
<p>Version 0.0.2</p>
			<p>0.0.2 - 配色完成</p>
			<p>0.0.2 - 基本模板完成</p>
			<p>0.0.2 - 自我介紹新增打字效果</p>




-->
		</footer>
		</div>
	</body>
</html>